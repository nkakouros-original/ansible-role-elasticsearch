---

elastic_enabled: true
# Set to false to completely disable the role

# Installation{{{
elastic_major_version: '7'
# The major version of elastic search to track. This will be used to add the
# relevant repository and install the latest release for that version.

elastic_user: root
# The user that will own elasticsearch files. Elasticsearch will be run as the
# `elasticsearch` user as defined in the systemd service file that comes with
# the elasticsearch installation, regardless of this setting. If you want to
# change that user as well, you can use the `elastic_systemd_override` variable
# to change the user that systemd will use to run elasticsearch.

elastic_group: elasticsearch
# The group that `elasticsearch_user` will be added to. If the `kibana_user` is
# `root`, the `root` user will not be added to this group. By default, when
# installing elasticsearch, the configuration files are owned by user `root` and
# group `elasticsearch`. The default behavior of the role is to replicate this,
# while giving the option to the user to run elasticsearch as an arbitrary
# user/group if they need to.

# Whether to exclude elasticsearch from automatic system updates. Set this to
# true if you want to manually update elasticsearch. This is valid only for
# Linux servers that may have some kind of unattended update mechanism.
elastic_disable_auto_update: false
# }}}
# Security{{{
elastic_builtin_users_password_backup_file: ~
# The role will set random passwords for the built-in users, using the
# `elasticsearch-setup-passwords` utility that comes with Elasticsearch.  You
# can use these passwords to login into elasticsearch.  Set this variable to
# a path on the ansible controller where these random passwords for the builtin
# users will be saved in. The records will be in a `{"name": user, password:
# pass}` format and can be loaded into an ansible variable with the `file`
# lookup plugin. If you leave this variable None, the new passwords will be only
# printed during provisioning and you will have no way of finding them
# afterwards. In this case, if you re-run the role, it will most probably fail,
# as the password is needed to interact with Elasticsearch. To avoid this,
# either save the passwords with this variable or provide a custom password for
# the `elastic` user in `elastic_users`.

elastic_users: []
# Example:
# elastic_users:
#   - name: my_user  # required
#     pass: my_pass  # required
#     enabled: true  # defaults to true
#     email: user@email.com
#     full_name: User Name
#     roles:         # you can also use `groups` instead of `roles`
#       - beats_admin
#
# Use this variable to create custom users on Elasticsearch. Depending on your
# workflow, you may also want to use this to add custom passwords for the
# built-in users, which will overwrite the random ones created by the role.
# }}}
# Certificates {{{
# You can use the variables in this section to generate certificates and
# upload them to elasticsearch nodes. These can then be used in
# `elastic_config` to setup TLS for the transport or http layer of
# elasticsearch.

elastic_certificates_password: ~
# The password to use to protect the generated private keys. Leave empty to set
# the empty string as the password. Certificates do need to have a password even
# if it is blank.

elastic_certificates_password_renew: false
# When uploading a certificate to a node, its password will be stored to the
# elasticsearch keystore on that node. If you change the
# `elastic_certificates_password` eg when renewing certificates, then the old
# password stored on a node's keystore will cause failures. Thus, if you are
# updating the certificate password, set this variable to true to update the
# node's keystore as well. The default here is false to support idempotency.

elastic_certificates: ~
# Use this variable to point to a certificate file on the ansible controller
# that should be uploaded to the elasticsearch node and be used as the
# certificate for that node. Eg:
# elastic_certificates:
#   ca: path/to/ca.cert
#   cert: path/to/node/cert
#   key: path/to/node/key

elastic_certificates_dir: /etc/elasticsearch/certs/
# The folder where `elastic_certificates` will be uploaded into.
# }}}
# Configuration {{{
elastic_jvm_min_heap_size: 1g
elastic_jvm_max_heap_size: 1g
# Set the minimum and maximum JVM heap size in jvm.options

elastic_jvm_extra_config: ~
# Use this to append extra configuration directives in the jvm.options file.
# These directives will override any previous ones in the jvm.options file. Eg:
# elastic_jvm_extra_config: |
#   -Des.networkaddress.cache.negative.ttl=10
#

elastic_systemd_override: ~
# Use this to override system settings using a systemd override. Eg:
# elastic_systemd_override: |
#   [Service]
#   LimitMEMLOCK=infinity

elastic_config: {}
# Elastic configuration in the form of a yaml array with non-collapsed keys.
# This will be merged with a default configuration shipped with this role. The
# variables below are used by the default configuration and you don't need to
# set them again. You could include that info directly in `elastic_config` and
# ignore these variables below. The `elastic_config` array will be output as is
# into the `/etc/elasticsearch/elasticsearch.yml` file. The default
# configuration can be found in the `vars/main.yml` file of this role. For what
# these settings do, consult the elastic search documentation.

elastic_bind_host: localhost
# The address where elastic will listen on for requests to its JSON api.

elastic_bind_port: 9200
# The port where elastic will listen on for request to its JSON api.

elastic_transport_host: "{{ elastic_bind_host }}"
# The address elastic search will use to communicate with other nodes in the
# cluster.

elastic_transport_port: 9300
# The port that elastic search will use to communicate with other nodes.

elastic_cluster_name: elasticsearch
# The name of the cluster the node will belong to.

elastic_cluster_initial_master_nodes:
  - "{{ elastic_node_name }}"

elastic_node_name: "{{ inventory_hostname }}"
# The name of the node

elastic_master_node: true
elastic_data_node: true
elastic_ingest_node: true
# Whether the provisioned node will be act as a master and/or data and/or ingest
# node.
# }}}
# Others {{{
elastic_index_templates_to_import: []
# This is a list of files that contain index templates that should be imported
# into elasticsearch. This is useful in cases you need to load an
# auditbeat/packetbeat/etc index template manually because the beat installation
# does not have direct access to elasticsearch. The format should be:
# elastic_index_templates_to_import:
#   - file: /path/to/json/template/file
#     index: the-name-of-the-index-template

elastic_ingest_pipelines: []
# A list of files that contain an ingest pipeline specification in yaml format.
# Example of an OpenVPN log file parsing pipeline:
# pipeline:
#   description: "openvpn-connection-log-line"
#   processors:
#     - grok:
#         field: message
#         ignore_failure: true
#         patterns:
#           - "%{TIMESTAMP:openvpn.date} %{DATA} \\[%{DATA:openvpn.common_name}\\] Peer Connection Initiated with \\[AF_INET\\]%{IP:openvpn.host}:%{POSINT:openvpn.port}"
#         pattern_definitions:
#           TIMESTAMP: "%{DAY} %{MONTH}  ?%{MONTHDAY} %{TIME} %{YEAR}"
#     - gsub:
#         field: "openvpn.date"
#         pattern: "  "
#         replacement: ' '
#     - date:
#         field: "openvpn.date"
#         formats:
#           - EEE MMM d HH:mm:ss yyyy
# }}}
